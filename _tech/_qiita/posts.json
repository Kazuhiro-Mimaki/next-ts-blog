[{"title":"【TypeScript】keyofメモ","link":"https://qiita.com/Kazuhiro_Mimaki/items/48e97aa11acea82bb872","content":"TypeScriptで keyof を利用すると、オブジェクトのプロパティ名を抽出し、ユニオン型を生成できる。\nkeyof T =&gt; T typeのプロパティ名のユニオン型 を表現できる。\n\ntype Item = {\n  title: string;\n  description: string;\n};\n\ntype ItemKey = keyof Item;\n// ItemKey は 'title'|'description' というユニオン型になる\n\n","isoDate":"2022-01-31T00:07:55.000Z","dateMiliSeconds":1643587675000},{"title":"Qiitaの人気記事を投稿するTwitter Botを作った","link":"https://qiita.com/Kazuhiro_Mimaki/items/47ffedf35b0dd944ed8f","content":"タイトルの通り、Qiitaの人気記事を投稿するTwitter Botを作成しました。(作成したのは約1年前なのですが、投稿するタイミングを逃していました...)\n\n\n\n\n\n\n仕様\n\nQiitaに投稿されたLGTM数の多い過去記事の中から、毎日1記事が投稿されます。\nスクレイピングとTwitter Botの処理はPythonを、定期実行はHerokuのタイムスケジューラを利用しています。\n「プログラミング」「エンジニア」というキーワードで検索した結果からLGTM数の多い順にソート。そこからランダムで取得した1記事を投稿するようにしています。\n\n\n作ってみてどうだったか\n\n作ってから1年ほど経過しているのですが、想像していたよりも幅広い分野から投稿されているように思います。\n毎日1記事なので、通学・通勤時間などに読むことができるのもちょうど良いです。\n\n\n投稿例\n\n\n\n\n\n\n\n\n\n\nまとめ\n\nフォローしていただけると喜びます！\n\n\n","isoDate":"2021-12-19T06:12:25.000Z","dateMiliSeconds":1639894345000},{"title":"【Go】入門（メソッドとレシーバ）","link":"https://qiita.com/Kazuhiro_Mimaki/items/8a4536385167f25e8b9a","content":"\n\nはじめに\n\nGo初心者です。\nメソッドとレシーバについてまとめてみました。\n\n\nメソッド / レシーバとは\n\nメソッドとはレシーバに呼び出される関数のこと。\nレシーバとはメソッドを呼び出す側のオブジェクトのこと。\n\n以下のコードだと、\n(p Person)がレシーバで、 Greet()がメソッド。\n\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) Greet() string {\n    return \"Hi, \" + p.Name\n}\n\n\n\nメソッドを使ってみる\n\nメソッドはレシーバで定義した構造体の変数から呼ぶことができる。\n下の例では、Person型の変数personが、Greetメソッドを呼んでいる。\n\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) Greet() string {\n    return \"Hi, \" + p.Name\n}\n\nfunc main() {\n    person := Person{Name: \"hoge\"}\n    fmt.Println(person.Greet())\n}\n\n\n\n値レシーバとポインタレシーバ\n\nレシーバには値レシーバとポインタレシーバの2種類がある。\nポインタレシーバ：ポインタ型を引数に渡すので、関数内でオブジェクトの値を変更できる。\n値レシーバ：元の値とは別のコピーした値を引数に渡すので、関数内で元の値は変更できない。\n\n以下のコードでは、\n（p Person）をレシーバとして定義しているのが値レシーバ。\n（p *Person）をレシーバとして定義しているのがポインタレシーバ。\n\ntype Person struct {\n    Name string\n}\n\n// 値レシーバ\nfunc (p Person) Greet() string {\n    return \"Hi, \" + p.Name\n}\n\n// ポインタレシーバ\nfunc (p *Person) Rename(newName string) string{\n    p.Name = newName\n    return p.Name\n}\n\n\n\nポインタレシーバを使う場面\n\n使う場面は2点ありそう\n\n\nその構造体型のデータの値を変えたい時\nメモリを効率的に利用したい時\n\n\n値レシーバがコピーした引数を用いるのに対して、ポインタレシーバでは構造体そのもののデータを操作できる。\nまた、引数をコピーするとそれだけ余分にメモリを消費するため、メモリ消費を抑えたい場合はポインタレシーバを使うと良さそう。\n","isoDate":"2021-07-14T21:45:58.000Z","dateMiliSeconds":1626299158000},{"title":"【Go】入門（構造体と関数を紐付ける）","link":"https://qiita.com/Kazuhiro_Mimaki/items/700f2910fa4e5f5c1512","content":"Goで構造体と関数を紐付ける方法についてのメモです。\n\n\nGoで構造体と関数を紐づける方法\n\nGoでは、class内にメソッドを定義できません。\nでは、どのように構造体ごとの関数を定義するのか？\n\npackage main\n\nimport \"fmt\"\n\ntype Human struct {\n    Name   string\n    Age    int\n}\n\nfunc (h Human) addAge(i int) int {\n    return h.Age + i\n}\n\nfunc main() {\n    // インスタンス生成\n    hoge := Human{\n        Name:   \"hoge\",\n        Age:    20,\n    }\n\n    fmt.Printf(\"%#v \\n\", hoge)\n    hoge.Age = hoge.addAge(1)\n    fmt.Printf(\"%#v \\n\", hoge)\n}\n\n\nつまり、構造体と関数の紐付けはこのようになります。\n\ntype Human struct {\n    Name   string\n    Age    int\n}\n\nfunc (h Human) addAge(i int) int {\n    return h.Age + i\n}\n\n\n一般化すると、こうですね。\n\ntype 構造体 struct {\n    // フィールド定義\n}\n\nfunc (変数名 構造体) 関数名(変数名 型) 型 {\n    // do something\n    return 値\n}\n\n\n（変数名 構造体）を関数の前に加えるだけで、構造体と関数が紐づけられます。\nここで定義した関数は構造体が作成されないと使用できません。\nこのようにして、構造体ごとに関数を定義することができます。\n","isoDate":"2021-07-11T23:22:15.000Z","dateMiliSeconds":1626045735000},{"title":"2021年に作るべき7つのフルスタックプロジェクト","link":"https://qiita.com/Kazuhiro_Mimaki/items/7ebe0fd766bcb6377f98","content":"以下はHenry Boisdequin( dev.to / Twitter / GitHub )による記事、7 Fullstack Projects You Need to Make in 2021の日本語訳です。\n\n\n\nどのようなフルスタックプロジェクトを作るべきか？\nもしこのような疑問を持ち続けているのであれば、あなたは正しい場所にいます。\n私は、2021年に作るべき7つのフルスタックプロジェクトのリストをまとめました。\n早速、挑戦してみましょう！\n\n\nE-commerce Site\n\n\nEコマースサイトとは、ユーザーが商品を購入できるサイトのことです（例：Amazon、eBayなど）。\nEコマースサイトを作ることで、セキュリティ、CRUD、データベース、フロントエンドフレームワーク、状態管理など、APIやウェブサイトを作るためのあらゆる部分について学ぶことができます。\nこれは、フルスタックのWeb開発をマスターしたい人にとって、最適なプロジェクトです。\n\n私の場合、技術スタックは以下のようになります：\n\n\nSvelte\nNode.js + Express\nTypeScript\nPostgreSQL\n\n\nチュートリアル (行き詰まった時のために)\n\n\nSocial Media App\n\n\nソーシャルメディアアプリはユーザーがオンライン上で交流できるアプリのことです（例：Instagram、Twitter、Facebookなど）。\nソーシャルメディアアプリの構築は、パフォーマンス、セキュリティ、アプリの外観を最適化して、ユーザーにとって魅力的なプラットフォームを作る方法を習得するのに最適な方法です。\n\n私の場合、技術スタックは以下のようになります：\n\n\nFlutter\nNode.js + Express\nMongoDB\n\n\nチュートリアル（行き詰まった時のために）\n\n\nBlog Site\n\n\ndev.toのようなブログサイトを作ろう！\nユーザーが自分の知識を他人と共有できるサイトを作ります。\nこれを行うことで、コンテンツ管理、API構築、CRUDなどについて学ぶことができます。\n\n私の場合、技術スタックは以下のようになります：\n\n\nNext.js\nChakra UI + Tailwind CSS\nNode.js + Express\nPostgreSQL\nRedis\n\n\nチュートリアル（行き詰まった時のために）\n\n\nTodo List\n\n\nTodoリストは、定番のフルスタックプロジェクトです。\nこのプロジェクトは、このリストの中で最も初心者向けのプロジェクトです。\nユーザーがログインして、リスト形式でTodoアイテムを追加・削除できるサイトを作ります。\nこのプロジェクトでは、認証、CRUD、データベースなどについて学ぶことができます。\n\n私の場合、技術スタックは以下のようになります：\n\n\nSvelte\nFlask\nPostgreSQL\n\n\nチュートリアル（行き詰まった時のために）\n\n\nWorkout Tracker\n\n\nこのプロジェクトは、リストの中でも特に気に入っている1つです。\nユーザーが完了したワークアウトを保存できるアプリを作成します。\nこれにより、フルスタック開発全般について学ぶことができます：例えば、認証、セキュリティ、CRUD、フロントエンドフレームワークなど。\n\n私の場合、技術スタックは以下のようになります：\n\n\nVue.js\nDjango\nMongo DB\n\n\nチュートリアル (行き詰まった時のために)\n\n\nChat App\n\n\n今、誰もが話題にしているフルスタックのプロジェクトです。\nこのプロジェクトでは、ユーザーがプライベートでチャットしたり、グループでチャットしたりできるウェブサイトを作成します。\nこのプロジェクトでは、リアルタイムのデータ転送、フロントエンドのフレームワーク、認証、セキュリティなどを学ぶことができます。\n\n私の場合、技術スタックは以下のようになります：\n\n\nReact.js\nFirebase + Firestore\n\n\nチュートリアル（行き詰まった時のために）\n\n\nZoom Clone\n\n\n2020年、Zoomは世界に旋風を巻き起こしました。\n私の知っている人は皆、仕事、学校、付き合い、運動など、生活のあらゆる場面でZoomを使っています。\nここでの課題は、webcomを使ってチャットができる「Zoom Clone」を作ることです。\nこのプロジェクトは、初心者の方にぜひおすすめしたいですね。\n\n私の場合、技術スタックは以下のようになります：\n\n\nWebRTC\nsocket.io\n\n\nチュートリアル（行き詰まった時のために）\n\n\n\nあなたがこれらのプロジェクトに取り組んでいくことを祈っています。\nまた、最近取り組んでいるフルスタックプロジェクトを教えてください、ぜひ拝見したいです！\nお読みいただきありがとうございました。\n\nHenry\n","isoDate":"2021-05-18T22:24:17.000Z","dateMiliSeconds":1621376657000},{"title":"【VS Code】指定ディレクトリに新規フォルダ・ファイルを作成するショートカットの設定","link":"https://qiita.com/Kazuhiro_Mimaki/items/46c64e36fbff21e0fde2","content":"\n\nはじめに\n\nVS Codeでファイルを新規作成する時のショートカットキーを調べたところ、デフォルトではなかったので、調べた結果のメモです。\n\n\nkeybindings.json を開く\n\ncmd+shift+pで Open Keyboard Shortcuts(JSON)を開く。\n\n\n\nキーバインディングを設定\n\n以下のように設定すれば cmd+n で新規ファイルを、 cmd+shift+n で新規フォルダを作成できるようになる。\n\n","isoDate":"2021-05-10T12:38:18.000Z","dateMiliSeconds":1620650298000},{"title":"【JavaScript】配列の差分を取得する","link":"https://qiita.com/Kazuhiro_Mimaki/items/f3df5e65ca97b62c70cd","content":"\n\nはじめに\n\n2つの配列から差分を取得したいと思い、調べたので実装方法をメモしておきます。\n「2つの配列の差分を取得する」というのは例えば以下のような例を想定しています。\n\n\n例\n\n配列1\n[1, 2, 3, 4, 5]\n\n配列2\n[1, 2, 3]\n\nこの2つの配列の差分[4, 5]を取得したい、ということです。\n\n\n実装方法\n\n今回の実装方法では filter 関数を使います。(もっと楽な方法があればぜひ教えてください)\n\nconst array1 = [1, 2, 3, 4, 5]\nconst array2 = [1, 2, 3]\n\nconst array3 = array1.filter(i =&gt; array2.indexOf(i) == -1)\nconsole.log(array3) //[4, 5]\n\n\nindexOfは値が見つからない場合に-1を返します。\nfilterとindexOfを利用することで、配列の差分を取得できました。\n","isoDate":"2021-05-09T09:24:34.000Z","dateMiliSeconds":1620552274000},{"title":"【TypeScript】PickとOmit","link":"https://qiita.com/Kazuhiro_Mimaki/items/ba808799fcc018ca6a65","content":"TypeScript 初心者です。\nReact の型定義で Pick と Omit について学習したのでまとめてみました。\n\n\nPick\n\nPick&lt;T, K&gt; は既に存在する T 型の中から K で選択したプロパティのみを含んだ新たな型を構築する。\n下記の例では、User型の name と email のみを含んだ UserItem型を作成している。\n\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n  address: string;\n};\n\ntype UserItem = Pick&lt;User, \"name\" | \"email\"&gt;;\n// | で複数指定可\n\nconst user: UserItem = {\n  name: \"hoge\",\n  email: \"hoge@example.com\",\n};\n\nconsole.log(user); // =&gt; {name: \"hoge\", email: \"hoge@example.com\"}\n\n\n\nOmit\n\nOmit&lt;T, K&gt;は既に存在する T 型の中から K で選択したプロパティを除いた新たな型を構築する。\n下記の例では、User から id と address を除いた UserItem型を作成している。\n\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n  address: string;\n};\n\ntype UserItem = Omit&lt;User, \"id\" | \"address\"&gt;;\n\nconst user: UserItem = {\n  name: \"hoge\",\n  email: \"fuga\",\n};\n\nconsole.log(user); //=&gt; {name: \"hoge\", email: \"hoge@example.com\"}\n\n","isoDate":"2021-04-12T22:39:23.000Z","dateMiliSeconds":1618267163000},{"title":"【Python】文字列の特定の文字を別の文字で置き換える","link":"https://qiita.com/Kazuhiro_Mimaki/items/b842255e5d8bb6e00387","content":"例えば、abcdeの3番目cをxで置き換えた文字列(abxed)が取得したい時。\n\n方法は3つ。\n\n\nstrを一度、listにしてから置き換える\n置き換える文字の前後をsliceで取得し、結合する\n文字の重複がない場合はreplaceで置き換える\n\n\n\nstrを一度、listにしてから置き換える\n\nstrのまま指定位置を置き換えようとするとエラー\n\n&gt;&gt;&gt; s = 'abcde'\n&gt;&gt;&gt; s[2] = 'x'\nTraceback (most recent call last):\n  File \"Main.py\", line 2, in &lt;module&gt;\n    s[2] = 'x'\nTypeError: 'str' object does not support item assignment\n\n\nだから、一度listにしてから置き換える\n\n&gt;&gt;&gt; l = list('abcde')\n&gt;&gt;&gt; print(l)\n&gt;&gt;&gt; l[2] = 'x'\n&gt;&gt;&gt; print(l)\n['a', 'b', 'c', 'e', 'd']\n['a', 'b', 'x', 'e', 'd']\n&gt;&gt;&gt; print(\"\".join(l))\n'abxde'\n\n\nこの方法で、リストデータの内容を書き換え、文字を置き換えた新たな文字列を作り出せる。\n\n\n置き換える文字の前後をsliceで取得し、結合する\n\n&gt;&gt;&gt; s = 'abcde'\n&gt;&gt;&gt; print(s[:2] + 'x' + s[3:])\n'abxde'\n\n\nこの方法でも、文字を置き換えた新たな文字列を作り出せる。\n個人的にはこっちの方が好き。\n\n\n文字の重複がない場合はreplaceで置き換える\n\n例のように c を x でというように置き換えたい文字が特定できており、かつその文字が1度しか登場しない場合は、replace で置き換えられる。\n\n&gt;&gt;&gt; s = 'abcde'\n&gt;&gt;&gt; s = s.replace('c', 'x')\n&gt;&gt;&gt; print(s)\n'abxde'\n\n\nただし、abaade など a が何度も現れるような文字列では全ての a が置き換わってしまうので注意。\n@dfghdfdjftyfghvgjhk さんありがとうございます。\n\n\n参考文献\n\n\nPythonで、文字列の一部の文字を変更する - minus9d's diary\nReplacing a portion of a string « Python recipes « ActiveState Code\nPython で文字列に変数を埋め込む方法あれこれ\n\n","isoDate":"2021-02-18T02:59:25.000Z","dateMiliSeconds":1613617165000},{"title":"Nuxt.js + Rails APIをDocker上で立ち上げCRUD操作してみる","link":"https://qiita.com/Kazuhiro_Mimaki/items/30093a6dff513b3d4b07","content":"今回初めて Nuxt.js を触りました。\nTodoアプリを作ろうかなと思ったのですが, せっかくならAPIを叩こうじゃないかということでサーバーサイドも用意してみました。\n\nサーバーサイドはRuby on Rails(API), クライアントサイドはNuxt.ts(Nuxt.js + TypeScript), DBはpostgresという構成で実装していきます。\n\n環境構築に関しては, サーバーサイド/クライアンドサイド共にDocker上で動かしており, ディレクトリ構成はモノシリックにまとめました。\n\n↓ソースコードはこちら\n\n\n\n動作環境\n\nmacOS Catalina : version 10.15.4\nDocker for macはインストール済みとする。\n\n\nディレクトリ構成\n\n\nディレクトリ構成\n.\n├── client-side\n├── server-side\n└── docker-compose.yml\n\n\n\n\n1. サーバーサイド(Ruby on Rails)\n\n\nDockerfile作成\n\nserver-side/ 配下にdockerfileを作成。\n\n\nDockerfile\nFROM ruby:2.7.0\n\nRUN apt-get update -qq &amp;&amp; \\\n  apt-get install -y \\\n  build-essential \\\n  libpq-dev \\\n  nodejs \\\n  postgresql-client\n\nWORKDIR /app\n\nCOPY Gemfil Gemfile.lock /app/\nRUN bundle install\n\n\n\n\nGemfile, Gemfile.lock作成\n\n同じく server-side/ 配下にGemfileとGemfile.lockを作成。\n\nGemfile内に以下を記述。\n\n\nGemfile\nsource 'https://rubygems.org'\ngem 'rails', '6.0.3'\n\n\n\nGemfile.lockは空のままで大丈夫。\n\n\ndocker-compose.yml作成\n\nrailsとpostgresの設定をdocker-compose.ymlに書いていきます。\n\n\ndocker-compose.yml\nversion: '3.8'\n\nvolumes:\n  db_data:\n\n  services:\n    db:\n      image: postgres\n      volumes:\n        - db_data/var/lib/postgresql/data\n      environment:\n        POSTGRES_PASSWORD: password\n\n    server-side:\n      build: ./server-side/\n      command: bundle exec rails server -b 0.0.0.0\n      image: server-side\n      ports:\n        - 3000:3000\n      volumes:\n        - ./server-side:/server-app\n      tty: true\n      stdin_open: true\n      depends_on:\n        - db\n      links:\n        - db\n\n\n\n\nAPIモードで rails new\n\n\n以下のコマンドを叩けば, server-side/ 配下にrails関連のファイル群が作成されます。\n\n$ docker-compose run server-side rails new . --api --force --database=postgresql --skip-bundle\n\n\n\ndatabase.yml の内容を修正\n\nこのままだとserver-sideのコンテナからDBのコンテナにアクセスできないので database.yml の内容を修正します。\n\n以下のようになっていると思うので\n\n\ndatabase.yml\ndefault: &amp;default\n  adapter: postgresql\n  encoding: unicode\n  # For details on connection pooling, see Rails configuration guide\n  # https://guides.rubyonrails.org/configuring.html#database-pooling\n  pool: &lt;%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %&gt;\n\n\n\n以下のように編集。\n\n\ndatabase.yml\ndefault: &amp;default\n  adapter: postgresql\n  encoding: unicode\n  host: db\n  user: postgres\n  password: password\n  # For details on connection pooling, see Rails configuration guide\n  # https://guides.rubyonrails.org/configuring.html#database-pooling\n  pool: &lt;%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %&gt;\n\n\n\n\nserver-side ホストを受け入れるように修正\n\nこの設定をすることで, Nuxtからserver-sideにアクセスできます。\n\n\nserver-side/config/environments/development.rb\nconfig.hosts &lt;&lt; \"server-side\"\n\n\n\n\nDBを作成\n\n以下のコマンドを叩いてdbを作成。\n\n$ docker-compose run server-side rails db:create\n\n\n\n動作させてみる\n\n以下のコマンドを打って, localhost:3000 にアクセス。\nrailsのデフォ画面が表示されればOK！\n\n$ docker-compose up -d\n\n\n\nサーバーサイドのAPIを実装\n\n以下のコマンドを叩き, コンテナの中に入った上で作業を進めていきます。\n\n$ docker exec -it server-side bash\n\n\nルーティングを設定。\n\n\nroutes.rb\nRails.application.routes.draw do\n  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html\n  namespace :api do\n    namespace :v1 do\n      resources :todos do\n        collection do\n          get :complete\n        end\n      end\n    end\n  end\nend\n\n\n\nTodoモデル, todosコントローラーを作成。\n\n$ rails g model Todo title:string isDone:boolean\n$ rails db:migrate\n$ rails g controller api::v1::todos\n\n\ncontrollerの中身は以下のように書きました。\n\n\napi/app/controllers/api/v1/posts_controller.rb\nclass Api::V1::TodosController &lt; ApplicationController\n  before_action :set_todo, only: [:update, :destroy]\n\n  def index\n    todos = Todo.where(isDone: false)\n    render json: { status: 'SUCCESS', message: 'Loaded todos', data: todos }\n  end\n\n  def complete\n    todos = Todo.where(isDone: true)\n    render json: { status: 'SUCCESS', message: 'Loaded todos', data: todos }\n  end\n\n  def create\n    todo = Todo.new(todo_params)\n    if todo.save\n      render json: { status: 'SUCCESS', data: todo }\n    else\n      render json: { status: 'ERROR', data: todo.errors }\n    end\n  end\n\n  def destroy\n    @todo.destroy\n    render json: { status: 'SUCCESS', message: 'Deleted the todo', data: @todo }\n  end\n\n  def update\n    if @todo.update(todo_params)\n      render json: { status: 'SUCCESS', message: 'Updated the todo', data: @todo }\n    else\n      render json: { status: 'ERROR', message: 'Not updated', data: @todo.errors }\n    end\n  end\n\n  private\n\n    def set_todo\n      @todo = Todo.find(params[:id])\n    end\n\n    def todo_params\n      params.require(:todo).permit(:title, :isDone)\n    end\nend\n\n\n\n\n\n動作確認\n\nこの記事を参考に, Postmanを利用してCRUD操作ができるかどうか確認します。\ncurlコマンドでも確認できますが, たぶんPostmanの方が楽。\n\n\n2. クライアントサイド(Nuxt.js)\n\n\n環境構築\n\n基本的には 公式のInstallation に沿って進めるだけ。\nnodeはインストール済みとします。(今回の環境では12/15現時点でのLTS ver. 14.15.1を使用しています。)\n\n\nプロジェクトの作成\n\nまずは create-nuxt-app で雛形作りましょう。\n\n$ npx create-nuxt-app client-side\n\n\n色々質問されると思うのですが, 今回は以下のように設定しました。(その他はデフォルト)\n\n\nterminal\n? Project name: client-side\n? Programming language: TypeScript\n? Package manager: Yarn\n? UI framework: None\n? Nuxt.js modules: Axios\n? Linting tools: None\n? Testing framework: None\n? Rendering mode: Single Page App\n? Deployment target: Server (Node.js hosting)\n? Development tools: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)\n? Continuous integration: None\n? Version control system: None\n\n\n\nこの辺りの設定は各自の好みで設定してください。\n全てのオプションは ここから 確認できます。\n\n\nDockerfile作成\n\nclient-side/ 配下にDockerfileを作成。\n\n\nDockerfile\nFROM node:14.15.1\n\nWORKDIR /client-app\n\nCOPY package.json yarn.lock ./\n\nRUN yarn install\n\nCMD [\"yarn\", \"dev\"]\n\n\n\n\ndocker-compose.ymlに client-side の設定を追加\n\nserver-side の設定を記述したdocker-compose.yml に client-side の設定を追加します。\n\n\ndocker-compose.yml\nversion: '3.8'\n\nvolumes:\n  db_data:\n\nservices:\n  db:\n    image: postgres\n    volumes:\n      - db_data/var/lib/postgresql/data\n    environment:\n      POSTGRES_PASSWORD: password\n\n  server-side:\n    build: ./server-side/\n    image: server-side\n    ports:\n      - 3000:3000\n    volumes:\n      - ./server-side:/server-app\n    command: bundle exec rails server -b 0.0.0.0\n    tty: true\n    stdin_open: true\n    depends_on:\n      - db\n    links:\n      - db\n\n  # ここから下を追加\n  client-side:\n    build: ./client-side/\n    image: client-side\n    ports:\n      - 8000:8000\n    volumes:\n      - ./client-side:/client-app\n      - /client-app/node_modules\n    command: sh -c \"yarn &amp;&amp; yarn dev\"\n\n\n\n\nportの設定\n\nこのままだとエラーが出るので, portとhostを以下のように設定します。\n\n\nnuxt.config.js\nexport default {\n  // Disable server-side rendering (https://go.nuxtjs.dev/ssr-mode)\n  ssr: false,\n\n  // ここを追記\n  server: {\n    port: 8000,\n    host: '0.0.0.0',\n  },\n\n// 以下省略\n}\n\n\n\n\n動作させてみる\n\n以下のコマンドを打って, localhost:8000 にアクセスするとNuxt.jsのデフォ画面が表示されます。\n\n$ docker-compose up -d\n\n\nこれで環境構築は完了！\n\n\n3. サーバーサイドとクライアントサイドの連携\n\nいよいよクライアント側からサーバーサイドのAPIを叩きにいきます。\n感動の瞬間。。。\n\n\nCORS (オリジン間リソース共有) 問題を解消\n\nCORSについては こちらの記事 が参考になると思います。\n公式とGitHubのREADMEに解決方法がありました。\nREADMEの記述を参考に @nuxtjs/proxy をインストールし, app/nuxt.config.js を以下のように編集します。\nサーバーサイドのポート番号をは3000で指定していたので, ここは server-side:3000で。(コンテナ間の通信はコンテナ名で解決するため, localhostではなくserver-sideにしている。)\n\n$ yarn add @nuxtjs/proxy\n\n\n\napp/nuxt.config.js\nmodules: [\n  '@nuxtjs/axios',\n  '@nuxtjs/proxy'\n],\n// 以下を追加\nproxy: {\n  '/api': {\n    target: 'http://server-side:3000',\n    pathRewrite: {\n      '^/api': '/api/v1/',\n    },\n  },\n},\n\n\n\n\nComposition APIとaxiosを設定\n\nこの辺り使いたいので設定しましたが, なくてもCRUD操作はできます。\n\n\nshell\n$ yarn add @nuxtjs/composition-api\n\n\n\n\nclient-side/nuxt.config.js\nmodules: [\n  '@nuxtjs/proxy',\n  //追加\n  '@nuxtjs/axios',\n  '@nuxtjs/composition-api',\n],\n\n\n\n\nclient-side/tsconfig.json\n\"types\": [\n  \"@types/node\",\n  \"@nuxt/types\",\n  #追加\n  \"@nuxtjs/axios\"\n]\n\n\n\n\n型定義\n\nclient-side に新たに models/todo.ts ディレクトリを作り, 以下を記述。\n\n\ntodo.ts\nexport interface ITodo {\n  id: number;\n  title: string;\n  isDone: boolean;\n}\n\n\n\n\nviewを記述\n\n本当はコンポーネントに分割して書くべきですが, 今回は1ファイルにまとめた方が見やすいかなと思ったのでまとめます。\n\nclient-side/pages/index.vue に以下の内容を記述。\n\n\nclient-side/pages/index.vue\n&lt;script lang=\"ts\"&gt;\nimport {\n  defineComponent,\n  reactive,\n  ref,\n  onMounted,\n} from \"@nuxtjs/composition-api\";\nimport { ITodo } from \"../models/todo\";\nimport $axios from \"@nuxtjs/axios\";\n\nexport default defineComponent({\n  setup(_, { root }) {\n    onMounted(() =&gt; {\n      getTodo();\n    });\n\n    const todoItem = reactive({\n      title: \"\",\n      isDone: false,\n    });\n\n    const todoList = ref&lt;ITodo[]&gt;([]);\n    const completeTodoList = ref&lt;ITodo[]&gt;([]);\n\n    // todoをpost\n    const addTodo = async () =&gt; {\n      try {\n        await root.$axios.post(\"/api/todos/\", {\n          title: todoItem.title,\n          isDone: todoItem.isDone,\n        });\n        getTodo();\n        todoItem.title = \"\";\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    // todoをget\n    const getTodo = async () =&gt; {\n      try {\n        const response = await root.$axios.get(\"/api/todos\");\n        todoList.value = { ...response.data.data };\n        getCompleteTodo();\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    // todoをupdate\n    const updateTodo = async (i: number, todo: ITodo) =&gt; {\n      try {\n        const newTodo = todoList.value[i].title;\n        await root.$axios.patch(`/api/todos/${todo.id}`, { title: newTodo });\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    // todoをdelete\n    const deleteTodo = async (id: number) =&gt; {\n      try {\n        await root.$axios.delete(`/api/todos/${id}`);\n        getTodo();\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    // todoをdone\n    const completeTodo = async (todo: ITodo) =&gt; {\n      try {\n        todo.isDone = !todo.isDone;\n        await root.$axios.patch(`/api/todos/${todo.id}`, {\n          isDone: todo.isDone,\n        });\n        getTodo();\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    // complete_todoをget\n    const getCompleteTodo = async () =&gt; {\n      try {\n        const response = await root.$axios.get(\"/api/todos/complete\");\n        completeTodoList.value = { ...response.data.data };\n      } catch (e) {\n        console.log(e);\n      }\n    };\n\n    return {\n      todoItem,\n      todoList,\n      completeTodoList,\n      addTodo,\n      deleteTodo,\n      updateTodo,\n      completeTodo,\n    };\n  },\n});\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div class=\"container\"&gt;\n    &lt;section class=\"todo-new\"&gt;\n      &lt;h1&gt;Add todos&lt;/h1&gt;\n      &lt;input v-model=\"todoItem.title\" type=\"text\" placeholder=\"todoを記入\" /&gt;\n      &lt;button @click=\"addTodo()\"&gt;Todoを追加&lt;/button&gt;\n    &lt;/section&gt;\n\n    &lt;section class=\"todo-index\"&gt;\n      &lt;h1&gt;Incomplete todos&lt;/h1&gt;\n      &lt;ul&gt;\n        &lt;li v-for=\"(todo, i) in todoList\" :key=\"i\"&gt;\n          &lt;input\n            class=\"item\"\n            type=\"checkbox\"\n            :checked=\"todo.isDone\"\n            @change=\"completeTodo(todo)\"\n          /&gt;\n          &lt;input\n            class=\"item\"\n            type=\"text\"\n            v-model=\"todo.title\"\n            @change=\"updateTodo(i, todo)\"\n          /&gt;\n          &lt;button @click=\"deleteTodo(todo.id)\"&gt;削除する&lt;/button&gt;\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/section&gt;\n\n    &lt;section class=\"todo-complete\"&gt;\n      &lt;h1&gt;Complete todos&lt;/h1&gt;\n      &lt;ul&gt;\n        &lt;li v-for=\"(todo, i) in completeTodoList\" :key=\"i\"&gt;\n          &lt;input\n            class=\"item\"\n            type=\"checkbox\"\n            :checked=\"todo.isDone\"\n            @change=\"completeTodo(todo)\"\n          /&gt;\n          {{ todo.title }}\n          &lt;button @click=\"deleteTodo(todo.id)\"&gt;削除する&lt;/button&gt;\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/section&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n.container {\n  margin: 80px auto;\n  min-height: 100vh;\n  text-align: center;\n}\n\nsection {\n  margin-bottom: 30px;\n}\n\n.item {\n  font-size: 1rem;\n  margin: 0 10x;\n}\n\nli {\n  list-style: none;\n  margin-bottom: 0.5em;\n}\n&lt;/style&gt;\n\n\n\n\n実際に動作させてみる\n\ndocker-compose upさせて, localhost:8000 にアクセスすると以下のような画面になると思います。\n\n\n\n実際にtodoを追加/編集/削除してみてください。\n\n\nまとめ\n\nDockerfileを1から書いたのも初めてだったので良い勉強になりました。\nNuxt.jsに関しては知らないことしかないので勉強していきます。\n「ここのコードもっとこうした方がいいよ！」というのがあればぜひアドバイスお願いします。\n","isoDate":"2020-12-15T04:22:02.000Z","dateMiliSeconds":1608006122000},{"title":"Atomic Design入門","link":"https://qiita.com/Kazuhiro_Mimaki/items/3d9a8594064aab5119da","content":"最近Atomic Designという考え方を学んだので、コンポーネント指向と絡めつつ僕なりの理解をアウトプットしてみます。\nAtomic Designもコンポーネント指向も初心者なので、誤りがあれば指摘してもらえると助かります。\n\n\nAtomic Designとは\n\nAtomic DesignとはUI設計の考え方で、「小さなUIコンポーネントを組み合わせて1つのページを作っていこう」というもの。\n僕のざっくりとした理解では、「小さなパーツを組み合わせ、徐々に意味のある大きな要素を作っていき、最終的に1つのページになる」みたいな感じです。\n\n\n5段階で捉えるUI構造\n\nAtomic Designで有名なのは、UIの構造を次の5段階に落とし込むという考え方。\n\n\n\n引用元：Atomic Design Methodology\n\n\n\natoms\n\n原子。それ以上分解できない最小単位。\nラベル、ボタン、アイコンなど。\nヘッダーを例にとるなら、ここがatoms。\n\n\n\nmolecules\n\n分子。atomsを組み合わせてできたもの。\nヘッダーナビゲーションや検索フォームなど。\nヘッダーを例にとるなら、ここがmolecules。\n\n\n\norganisms\n\n生物。atomsやmoleculesを組み合わせてできたもの。意味を持っている単位。\nヘッダーそのものがorganisms。\natomsとmoleculesが組み合わさってヘッダーになる。\n\n\n\ntemplates\n\n骨組み。例えば、ヘッダーとサイドナビゲーションは全てのページで固定化し、メインコンテンツだけが異なるページを作っていく場合などに便利。\nここに関しては後半でもう一度紹介します。\n\n\n\npages\n\nページ。atoms, molecules, organisms, templatesが組み合わさって1つのページとなる。\n\n\n\nAtomic Designを採用すると何が嬉しいか？\n\nAtomic Design/コンポーネント指向を採用するメリットはこんな感じかなと思います。\n1. 再利用性が高まる\n2. 小さな単位で問題を捉えられる\n3. 全体のデザインに一貫性が出る\n\n\n1. 再利用性が高まる\n\nページ内で何度も出てくるようなUIパーツは、コンポーネントとしてまとめておけば使い回すことができます。\n\n\n2. 小さな単位で問題を捉えられる\n\nコンポーネント指向の強みは疎結合な状態を作り出せることです。(コンポーネント同士の結びつきが弱く独立性が高い状態)。そのため、問題が発生したときに(変更したい/取り除きたいなど)、単位を小さく捉えることができ解決しやすくなります。\n\n\n3. 全体のデザインに一貫性が出る\n\nコンポーネントを使い回すことで、「このボタンだけデザインがおかしい」みたいなことが防げるので、全体に一貫性が出ます。\n\n\nコンポーネント指向でファイルを分割すると何が嬉しいか？\n\nAtomic Designのメリットがわかってきたところで、具体例を交えながらコンポーネント指向のメリットも見ていきます。\n\n\n例1. ここのボタンの色変えたい...\n\n\n\nコンポーネントとしてこのボタンを作っておけば、ボタンコンポーネントの色を変えるだけで全てのボタンにその変更が反映されます。もしコンポーネントに分けていなかったら、1つずつボタンを定義しているコードを探し出して、それを1つずつ直していかないといけません。このページのボタンだけならまだ楽ですが、ページの数・ファイルの数が増えてくるといちいち探して直していくのはかなり面倒になってきます。\n\n\n例2. この部分差し替えたい...\n\n\n\nページのこの部分を丸ごと別の要素に差し替えたいみたいな場合。コンポーネントとして独立させておけば、それを入れ替えるだけで目的は達成されます。しかし、コンポーネントにしていなければ、ファイルの中からこの部分を探し出さなければいけません。面倒ですね。\n\n\n例3. ページに応じてコンテンツだけを変更したい...\n\n\n\nヘッダーとサイドナビゲーションは他のページでも同様のレイアウトを保ちたいという場合。ページごとで毎回それを書いていたら無駄が多くなってしまいます。そんな時はテンプレートを作ってコンテンツだけ差し替えられる形にするのが良さそうです。Vue.jsのvue-routerなどはこの考えに基づいて実装していくイメージです。\n\n\nAtomic Design/コンポーネント指向のデメリット\n\nここまで良いところばかりを紹介してきましたが、デメリットもあります。\n1. ファイル数が激増する\n2. 開発メンバー間で理解の齟齬があると辛い\n3. エンジニア・デザイナー間のコミュケーションの難しさ\n\n\n1. ファイル数が激増する\n\n小さなコンポーネントもどんどん切り分けていくとファイル数が激増します。1フォルダで管理しきれないほどのファイル数になる場合は、フォルダを切り分けていくのも1つの解決策かなと思います。\n\n\n2. 開発メンバー間で理解の齟齬があると辛い\n\nチーム開発する際に、コンポーネントの単位をチームメンバーとすりあわせておかないと、逆にごちゃごちゃしてしまう可能性があります。開発を始める前、コンポーネントの単位に悩んだ時は、チームで意見のすり合わせをした方がいいかなと思います。\n\n\n3. エンジニア・デザイナー間のコミュニケーションの難しさ\n\nAtomic Designはどちらかというと開発者寄りの考え方かなと思います。Atomic Designの考え方を汲んでいるデザインはやはり開発しやすいです。Atomic Designを理解していないデザイナーさんと一緒に仕事する場合は、UI設計について少し議論する必要もあるのかなと思います。\n\n\nまとめ\n\nAtomic Designとコンポーネント指向について見てきました。\nVue.js, React, Angularなど、フロントエンドの技術はコンポーネント指向に基づく実装がデファクトスタンダードになりつつあります。なので、このようなUI設計の考え方も重要性が増してきている気がします。\n\nUI設計の考え方は他にも色々あるので、すべての場合にAtomic Designが有効かというと、そうではないと思います。さらにAtomic Designの中でも、「どの要素をmoleculesやorganismsの範疇に含めるのか」、「ディレクトリ構成はどうしていくのか」など常につきまとう問題がいくつかあります。最後まで気持ちよく開発をしていくためにも、チームメンバーと理解をすりあわせ、適切な判断をしていきたいですね。\n\n\n参考\n\n\nAtomic Design Methodology\nウェブラボスタッフブログ\nもっと効率的にデザインできる！「アトミックデザイン」を紹介します\n\n","isoDate":"2020-11-25T10:32:38.000Z","dateMiliSeconds":1606300358000},{"title":"[mac]スクリーンショットを超快適にしよう","link":"https://qiita.com/Kazuhiro_Mimaki/items/005ad8dfefeeaa7f2421","content":"Macでスクリーンショットを利用する際のtipsをシェアします。\n\n\nスクリーンショットする際のショートカットキー\n\nCommand + Shift + 3\n画面全体をキャプチャ。\n\nCommand + Shit + 4\nマウスで選択した範囲のみキャプチャ。\nマウスカーソルの形状が変わるのでキャプチャしたい範囲をドラッグで決める。\nESCでキャンセル。\n\n\n保存せず、そのままクリップボードにコピーしたい場合\n\nこれ超便利！知らない人は人生半分損してる。。。\nドキュメント貼り付け作業が捗ります。\n\nCommand + Shift + Control + 3\n画面全体\n\nCommand + Shit + Control + 4\nマウス選択の範囲。\n\n上記のショートカットキー＋Controlキーを押すだけ。\n\n\n保存場所を変更\n\nデフォルトではデスクトップに保存されますが、任意のディレクトリに移動できます。\nデスクトップにスクショ溜まるのうざいので、これは良い！\nコマンドラインから設定し、再起動すれば反映されます。\n\n↓今回は ~/Downloads/ に設定していますが、別のディレクトリも指定可能。\n\n\nterminal\n$ defaults write com.apple.screencapture location ~/Downloads/　\n↓デフォルトに戻す場合はこちら。設定値を削除するイメージです。\n$ defaults delete com.apple.screencapture location\n\n\n\n↓やっぱりデフォルトに戻したい場合。\n\n\nterminal\n$ defaults delete com.apple.screencapture location\n\n\n\n\n保存形式を変更\n\nデフォルトではpngで保存されます。\n複数のファイル形式を指定できます。\n用途に応じて保存時に形式変更できるので最高！\nこちらもコマンドラインから設定し、再起動すれば反映されます。\n\n↓今回はjpgで保存する場合のコマンド。\n\n\nterminal\ndefaults write com.apple.screencapture type jpg;\n\n\n\n\nまとめ\n\nこれであなたのスクリーンショットライフは超快適になること間違いなしですね！\n\n\n参考\n\n\nmacOSのスクリーンショット設定を変更する\nMacでスクリーンショットを撮る方法と保存先＆形式を変える方法\n\n","isoDate":"2020-11-13T02:05:04.000Z","dateMiliSeconds":1605233104000},{"title":"[Rails]いいね数順でランキングかつページネーション","link":"https://qiita.com/Kazuhiro_Mimaki/items/fbac42fa51bba304b8a7","content":"以前このような記事を書きました。\n[Rails]いいね数順でランキング\n\nこの内容に加え、ページネーションを実装したのでメモとして残しておきます。\n今回はいいね数順で並び替えた投稿を1ページに5つ表示させるページネーションの実装を目指します。\n\n\n前提\n\n\n投稿のテーブルは posts、 ユーザーのテーブルは users とする。\nいいね機能に必要な中間テーブルは likes とする。\n\nposts・users・likes それぞれのテーブルはいずれも作成済みとする。\nページネーションはKaminariというgemを使用して実装\n\n\n\n手順\n\n\nモデルにアソシエーションを定義\n\n\npost.rb\nclass Post &lt; ApplicationRecord\n    belongs_to :user\n    has_many :likes, dependent: :destroy\n    has_many :liked_users, through: :likes, source: :user\nend\n\n\n\n\nuser.rb\nclass User &lt; ApplicationRecord\n  has_many :posts,dependent: :destroy\n  has_many :likes, dependent: :destroy\n  has_many :liked_posts, through: :likes, source: :post\nend\n\n\n\n\nlike.rb\nclass Like &lt; ApplicationRecord\n  belongs_to :post\n  belongs_to :user\nend\n\n\n\n\nKaminari をGemfileに追記し, bundle install\n\n\n\nGemfile\ngem 'kaminari', '~&gt; 0.17.0'\n\n\n\n$ bundle install\n\n\n\nコントローラーをいじる\n\n\napp/controller/posts_controller.rb\ndef index\n  posts = Post.includes(:liked_users).sort {|a,b| b.liked_users.size &lt;=&gt; a.liked_users.size}\n  @posts = Kaminari.paginate_array(posts).page(params[:page]).per(5)\nend\n\n\n\nここでは sort というrubyのメソッドを使って順序を操作している。\n=&gt; sortに関してはこちらを参照\n\na.liked_users.size、b.liked_users.size が表しているのはそれぞれ各投稿のいいね数。\nすなわち、各投稿のいいね数を比較して昇順で並び替えている。\n\nsortメソッドによって生成されるpostsという変数は配列のデータなので、paginate_arrayというメソッドを使用している。\n\n\nビューで表示させる\n\nあとはビューで表示させるだけ。\n\n\napp/view/posts/index.html\n&lt;% @posts.each do |post| %&gt;\n\n  #省略\n\n&lt;% end %&gt;\n&lt;%= paginate @posts %&gt;\n\n\n\nまだまだ知らないメソッドたちはたくさんあるなぁ。\n\n\n参考\n\n\nArray#sort (Ruby 2.7.0 リファレンスマニュアル)\n[rails]kaminariを使ってページネーションを作る\nkaminariを使って配列に対してのページャーを作成する\n\n","isoDate":"2020-11-11T11:17:46.000Z","dateMiliSeconds":1605093466000},{"title":"rebase完全に理解した","link":"https://qiita.com/Kazuhiro_Mimaki/items/357b3ef4259aac9c20ea","content":"最近実務で初めてrebaseを使って「？？？？」となったので調べました。\n\n以下の動画、記事が分かりやすかったです。\n- Git MERGE vs REBASE\n- マージとリベース\n\n\n具体例\n\n今回は動画から引用してこのような場合を考えてみます。\n\n\nm2まで作業が進んでいるmasterブランチからfeatureブランチへcheckout\nfeatureブランチでf1をコミット\nmasterブランチにcheckoutしてm3をコミット\n再度featureブランチにcheckoutしてf2をコミット\n\n\n\n\n\nここまでの各ブランチのlog\n\n\nmasterブランチのlog\n\nm3\nm2\nm1\n\n\n\nfeatureブランチのlog\n\nf2\nf1\nm2\nm1\n\n\n\nmerge vs rebase\n\nここからfeatureブランチにて、masterブランチをmerge, rebaseするとそれぞれどうなるか見ていきます。\n\ngit merge masterのlog\n\nf2\nm3\nf1\nm2\nm1\n\n\ngit rebase masterのlog\n\nf2\nf1\nm3\nm2\nm1\n\n\nmergeでは時系列に沿ってそのまま差分を統合しているのに対し、rebaseではfeatureブランチの先端がmasterで置き換えられています。\nrebaseを用いるとコミット履歴がすっきりしますね。\n\n\nrebaseのアンチパターン\n\nこの記事から引用します。\n\n\nリベースの特徴を理解できたら、次に最も重要なことは、実行してはいけないときを知ることです。git rebase の黄金律は、リベースを public ブランチでは決して使用しないことです。\n\n\nmasterブランチにて、自分の作業ブランチをrebaseしてしまうとmasterのコミット履歴が書き換えられてしまいます。\nこのように、他の人にも共有済みのブランチでrebaseは使わないように注意しましょう。\n","isoDate":"2020-10-25T02:26:32.000Z","dateMiliSeconds":1603592792000},{"title":"[Rails] webpackerでCSSを読み込みたい","link":"https://qiita.com/Kazuhiro_Mimaki/items/f158a5fbd5a642432379","content":"railsのver.6以上を使うなら asset pipeline ではなく webpacker でCSSを読み込みたいと思い、実装したのでメモです。\n\n\nディレクトリ構成\n\nwebpacker のREADME.mdより。\n\napp/javascript:\n  └── packs:\n      # only webpack entry files here\n      └── application.js\n      └── application.css\n\n\n\n手順\n\nrails new は完了しているものとします。\nrails6より下のversion使ってる人はwebpackerもインストールしましょう。\n\n\n新規フォルダ・ファイル作成\n\n↑のディレクトリ構成に従う。\napp/javascript/packsに application.css ファイルを作成\n\n\nエントリーポイント\n\nエントリーポイントは packs/application.js なので、application.cssファイルをimport。\n\n\npacks/application.js\nimport \"packs/application.css\";\n\n\n\n\napplication.html.erbを編集\n\nviews/layouts/application.html.erb に以下を記述。\nおそらくデフォルトだと stylesheets_link_tag になっているので、そこを stylesheets_pack_tag に変更すればいいかと。\n\n&lt;%= javascript_pack_tag 'application' %&gt;\n&lt;%= stylesheet_pack_tag 'application' %&gt;\n\n\n\nCSSを書く\n\nあとはCSSを書くのみです。\n次はReact、Vue.jsあたりも導入してみたい。\n\n今回は手順だけをメモした感じなので、もう少し詳しく中身を知りたい人は↓が参考になると思われます。\n\n\n参考\n\nRails 6+Webpacker開発環境をJS強者ががっつりセットアップしてみた（翻訳）\nwebpackerでcssとimagesを参照したい\nwebpacker でページごとにスタイルを分ける\n","isoDate":"2020-08-24T00:11:11.000Z","dateMiliSeconds":1598227871000},{"title":"[Rails] いいね数順でランキング","link":"https://qiita.com/Kazuhiro_Mimaki/items/1f8e851b957f511c88e9","content":"今回はいいね数の多い順(いいね数が0も含む)に投稿を表示させるランキング機能の実装方法についてです。\nランキング機能の実装方法は他でもあったのですが、いいねが0の投稿も表示させている記事が見当たらなかったので実装してみました。\n\n\n前提\n\n\n投稿のテーブルは posts、 ユーザーのテーブルは users とする。\nいいね機能に必要な中間テーブルは likes とする。\n\nposts・users・likes それぞれのテーブルはいずれも作成済みとする。\n\n\n\n手順\n\n\nモデルにアソシエーションを定義\n\n\npost.rb\nclass Post &lt; ApplicationRecord\n    belongs_to :user\n    has_many :likes, dependent: :destroy\n    has_many :liked_users, through: :likes, source: :user\nend\n\n\n\n\nuser.rb\nclass User &lt; ApplicationRecord\n  has_many :posts,dependent: :destroy\n  has_many :likes, dependent: :destroy\n  has_many :liked_posts, through: :likes, source: :post\nend\n\n\n\n\nlike.rb\nclass Like &lt; ApplicationRecord\n  belongs_to :post\n  belongs_to :user\nend\n\n\n\n\nコントローラーをいじる\n\n\napp/controller/posts_controller.rb\ndef index\n  @posts = Post.includes(:liked_users).sort {|a,b| b.liked_users.size &lt;=&gt; a.liked_users.size}\nend\n\n\n\nここでは sort というrubyのメソッドを使って順序を操作している。\n=&gt; sortに関してはこちらを参照\n\na.liked_users.size、b.liked_users.size が表しているのはそれぞれ各投稿のいいね数。\nすなわち、各投稿のいいね数を比較して昇順で並び替えている。\n\n\nビューで表示させる\n\nあとはビューで表示させるだけ。\n\n\napp/view/posts/index.html\n&lt;% @posts.each do |post| %&gt;\n\n  #省略\n\n&lt;% end %&gt;\n\n\n\nまだまだ知らないメソッドたちはたくさんあるなぁ。\n\n\n参考\n\n\nArray#sort (Ruby 2.7.0 リファレンスマニュアル)\n\n","isoDate":"2020-08-20T15:06:47.000Z","dateMiliSeconds":1597936007000},{"title":"聞いたことはあるがよくわからないJavaScript周辺のあれこれ","link":"https://qiita.com/Kazuhiro_Mimaki/items/fe6bac9cce78cacdc509","content":"JavaScriptを学習していると、よくわからない概念やライブラリに出会う機会が多いです。\nその中でも特によく耳にするものをざっくりまとめてみました。(ホントにざっくり)\n各内容をもっと掘り下げた参考記事も貼っているので気になる方はそちらも読んでみてください。\n\n\nECMAScript\n\nECMAScriptとはJavaScriptの言語仕様の取り決め。\nよく耳にする ES2015 や ES6 といった用語はJavaScriptのバージョンを表し、ここで出てくる ES がECMAScriptのこと。\n\n【JavaScript】JavaScript、その前に〜ECMAScriptとは？\n\n\nnpm\n\nNode Package Manager、すなわちNode.jsのパッケージを管理するもの。\nnpmのおかげで、 npm install 〇〇 と打つだけで便利なライブラリを簡単にインストールして利用することができる。\n\nnpmとは\n\n\nyarn\n\n2016年にFacebookが公開したかなり新しめのJavaScriptパッケージマネージャ。\n役割はnpmとほぼ同じだが、npmと比べてインストール・セキュリティ・バージョン管理の面で優れている。\n\nyarnとは\n\n\npackage.json\n\nパッケージマネージャを用いてプロジェクトを作成する際に、プロジェクトが依存するパッケージに関する情報（さらにはプロジェクト全体に関する情報）を記録するファイルがpackage.json。\nプロジェクトを動作させるために必要なパッケージをdependencies属性とdevDependencies属性に記述しておけば、npm install コマンドを打つだけでプロジェクト環境を復元できるため、非常に便利。\n\n【初心者向け】NPMとpackage.jsonを概念的に理解する\n\n\nBabel\n\nBabelはJavaScriptのコンパイラ。\nこれを使うとJavaScriptのコードを新しい書き方から古い書き方へと変換してくれる。\nブラウザによって対応しているJavaScriptのバージョンや仕様が異なるので、各ブラウザの環境に合わせて記法を変換する必要がある。\n\n【５分でなんとなく理解！】Babel入門\nwebpackとBabelの基本を理解する(1) ―Babel編―\n\n\nwebpack\n\nwebpackはモジュールバンドラ。\nモジュールバンドラとは、複数のファイルを１つにまとめて出力してくれるツールのこと。\nwebpackはJSファイルだけでなく、CSSや画像ファイルも1つにまとめてくれる。\nwebpackを使えば、開発時には機能ごとにファイルを分割して開発を進めることができ、読み込み時には1つのファイルとして読み込めるので、非常に便利。\n\nwebpackってどんなもの？\nwebpackとBabelの基本を理解する(1) ―webpack編―\n\n\nESLint\n\nESLint は JavaScript のための静的検証ツール。\nコードを実行する前に明らかなバグを見つけたり、括弧やスペースの使い方などのスタイルを統一したりするのに役立つ。\n\nESLint 最初の一歩\n","isoDate":"2020-08-09T01:08:11.000Z","dateMiliSeconds":1596935291000},{"title":"[Rails] link_toのリンク先を別タブで表示させたい","link":"https://qiita.com/Kazuhiro_Mimaki/items/b3f2d718d2bae9083290","content":"Railsでlink_toを使うときに別タブで表示させたいと思い、実装したのでメモとして残しておきます。\n\n\n手順\n\nまず link_to で表示させたい文字列とリンク先URLを指定。\n\n&lt;%= link_to \"文字列\", \"リンク先URL\" %&gt;\n\n\n別タブで表示させるため、target: :_blank を追加\n\n&lt;%= link_to \"文字列\", \"リンク先URL\", target: :_blank %&gt;\n\n\nこれで別タブで開けるようになる。\nしかし、これだとパフォーマンスとセキュリティの面で問題が。。。\n\n\n\nグーグルのエンジニアが警告、「別タブで開く」リンクは実はヤバいんだって！？【SEO情報まとめ】 \n実はヤバい？危険な「別タブで開く（target=”_blank”）」\n\n\nこの問題を回避するためには rel=\"noopener noreferrer\" をつけるといいみたい。\n\n&lt;%= link_to \"文字列\", \"リンク先URL\", target: :_blank, rel: \"noopener noreferrer\" %&gt;\n\n\nこれで安心して別タブを開けます。\n","isoDate":"2020-07-11T03:35:15.000Z","dateMiliSeconds":1594438515000},{"title":"大学生がVue.jsを使って3日間でポートフォリオを作成してみた","link":"https://qiita.com/Kazuhiro_Mimaki/items/94c88f69d0c56cee4f16","content":"Vue.jsでポートフォリオを作ったのでまとめました。\n\n\n作ったサイト\n\n\n\n\n動機\n\n今回サイトを作った動機は「自分のポートフォリオサイト持ってるのってなんかかっこいいよなぁ」と思ったからです。ちょうどいいアウトプットにもなりそうだったので作ることにしました。かかった期間は3日間。時間でいうと20時間くらいです。\n\n\n1日目\n\n\nサイトの構成を練る\n\nネット上で他の方が作ったポートフォリオを色々見まくって考えました。\n内容は以下の４項目に決めました。他の学生のポートフォリオを見ていると、インターンの開発経験や研究の内容を盛り込んでいる人も結構いましたが、自分は書くことがなかったのでその項目は外しました。悲しい。。。\n\n\nTop(トップページ)\nAbout(プロフィール)\nSkills(使ってきた技術)\nWorks(制作物)\n\n\nデザインに関しても色々な方のポートフォリオを参考にしました。色やレイアウトはなるべくシンプルなものを目指しました。\n\n\n使用技術の選定\n\n基本的なレイアウトやデザインはHTML/CSS、動きをつけたりコンポーネントをまとめる部分でVue.jsを中心に使おうと決めました。Vue.jsを選択した理由は大きく2つ。1つ目の理由は他のライブラリやフレームワーク(ReactやAngularなど)と比べてとっつきやすいから、2つ目は人気そうだから、です(笑)。実際触ってみてかなり使いやすかったのでポートフォリオ作成したい人はVue.jsオススメです！\n\n\n環境構築 &amp; 大枠の実装\n\nVue.js を vue-cli を使ってシンプルにはじめてみる という記事を見ながらVue CLIを使ってプロジェクトを作成しました。\nサイトの大まかなレイアウトやデザインを実装しました。細かいアニメーションやリンクの対応はまだできていない状態でした。\n\n\n2日目\n\n\nおしゃれなライブラリを導入\n\nVue.jsでポートフォリオを書くという記事に書かれていたvue-typerとsmoothScrollという2つのライブラリを導入しました。サイトに簡単な動作をつけたい人にはオススメです。\n\n\nhover時の動作\n\nボタンや画像のhoverに応じた色の変化や表示非表示の切り替えなどの動作をつけていきました。この辺ができてくると動きが出てきて楽しい。\n\n\n3日目\n\n\nレスポンシブデザイン\n\n今だとスマホで見る人が圧倒的に多いので、レスポンシブは必須かなと思い導入しました。レイアウトとフォントサイズの調整が主だったので割と簡単でした。1つ大変だったのがハンバーガーメニューです。ヘッダーにサイドバーを表示させるためのハンバーガーメニューを実装しました。Vue.jsのトランジションを取り入れて滑らかなアニメーションが実現できたかなと思います。(よかったらスマホで見てみてください...！)\n\n\nサイト公開\n\nデプロイはNetlifyを利用しました。GitHubと連携させて自動デプロイができるので超便利です。vue-cliとNetlifyで始めるお手軽サイトホスティングという記事を見れば簡単にホスティングできます。Github Pagesでもいいと思います。\n\n\nもう少しやりたかったこと\n\n\nディレクトリ構成 &amp; 単一ファイルコンポーネント\n\n実際にプロジェクトを作成していく中でディレクトリ構成に悩みました。そこで Vue.js ディレクトリ構成 色々試してみた という記事を参考にModules &amp; Pagesパターンを採用してプロジェクトに反映させようとしました。Modulesに再利用可能なコンポーネント、Pagesに基本的なページ構成を書いていく、という考え方です。Vue.jsには単一ファイルコンポーネントという考え方があります。これは部品の再利用性や可読性を高めるために、レイアウトを部品ごとに分けて実装しようという考え方です。ディレクトリ構成は考えたもののうまくコンポーネントをまとめられなかったので、この辺はもう少し勉強して改善したいところです。\n\n\nアニメーション\n\nCSSアニメーションやVue.jsのトランジションを絡ませてサイトに動きをつけようとしたのですが、結構大変でした。上の方でも触れているハンバーガーメニューの実装は頑張りましたが、他のアニメーションに関しては今回は諦めました。時間ができたらまた挑戦したいです。\n\n\nまとめ\n\n思っていたより楽に良さげなサイトを作ることができました。「お手軽にポートフォリオ作ってみたい！」という方はぜひVue.js使ってみてください。では！\n\n\n参考記事\n\n\nVue.js を vue-cli を使ってシンプルにはじめてみる\nVue.jsでポートフォリオを書く\nフロント未学習の大学生が1週間でVue.jsを使ったポートフォリオを作った話\nvue-cliとNetlifyで始めるお手軽サイトホスティング\n\nVue.js ディレクトリ構成 色々試してみた \n\n\nその他様々なポートフォリオサイトを拝見し、参考にさせていただきました。\n","isoDate":"2020-06-30T01:31:51.000Z","dateMiliSeconds":1593480711000},{"title":"webサーバとアプリケーションサーバって何が違うんだろう？","link":"https://qiita.com/Kazuhiro_Mimaki/items/9f85fd1a5ae65a05a403","content":"「webサーバとアプリケーションサーバって何が違うんだろう？」、ふと思ったのでまとめた。\n\n\nサーバとは\n\nまずサーバって何？という話。サーバは英語でserver、つまり供給する・提供するってこと。IT用語辞典 によるとサーバとは、コンピュータネットワークにおいて、他のコンピュータに対し、自身の持っている機能やサービス、データなどを提供するコンピュータのこと。私たちがwebページを閲覧するとき、自分のPCから「このページ見たい！」とサーバにお願いする。すると、サーバが「はい、これ！」とページを返してくれる。これで、めでたくwebページが見れる。通常、個々のサーバ機やサーバソフトは、外部に提供する機能やサービス、対応しているデータ形式やプロトコル（通信規約）が決まっている。そして、「DBサーバ」「webサーバ」「アプリケーションサーバ」のように、提供する機能などの種類を冠して「○○サーバ」と呼ぶ。\n\n\nwebサーバ\n\nwebサーバはブラウザからのコンテンツのリクエストを受け取り、ブラウザにレスポンスを返すのが役割。このときのリクエストが静的なwebコンテンツだった場合(HTML、CSS、画像ファイルのような更新しない限り同じ表示コンテンツを表示するコンテンツ)、webサーバが処理してレスポンスを返す。また、クライアントごとに表示内容を変化させる処理が必要な動的なwebコンテンツの場合、webサーバはアプリケーションサーバへとリクエストを送る。そして、アプリケーションサーバから返ってきた結果をレスポンスとして返します。webサーバとして有名なのは Nginx、Apache など。\n\n\nアプリケーションサーバ\n\nアプリケーションサーバは私たちが作ったアプリケーションを動かしてくれるもの。webサーバから送られてきたリクエストをアプリケーションサーバからアプリケーションに伝え、アプリが処理した結果をwebサーバに返す。ローカル環境下での開発の場合はアプリケーションサーバのみを立てるが、本番環境ではwebサーバをアプリケーションの手前に置くことで、静的なコンテンツの処理を負担させることが多い。\n\n\n例えばRailsだったら\n\nRailsのアプリケーションサーバとして代表的なのはUnicorn、Thin、Rainbows、Pumaなど。webサーバから送られてきたリクエストをアプリケーションサーバからRailsアプリケーションに伝え、Railsアプリが処理した結果をwebサーバに返す。ローカル環境下での開発の場合はPumaのようなRails用のアプリケーションサーバのみを立てる(普段development環境でやってるやつ)。一方、本番環境(production環境)ではwebサーバをRailsアプリケーションの手前に置き、静的なコンテンツの処理を負担させることが多い。こうすることで、Webサーバが複数のアプリケーション一度に処理したり、アセットを素早くレンダリングしたりして、リクエストごとに発生する多くの処理をさばいてくれる。\n\n\nRack\n\nここでRackに触れておく。RackとはRuby製のフレームワークとアプリケーションサーバの間に入り、互いをつなぐ役割をしてくれる。サーバはRackを使用することで、送られてきたHTTPのリクエストがアプリにも理解できる形に変換される。逆にアプリからのレスポンスはRackを通じてHTTPに変換されてサーバに返る。Rackを使用することでサーバとフレームワークの組み合わせが自由になる。\n\n\nまとめ\n\nここまでの内容をまとめる。ブラウザから送られてきたリクエストをwebサーバが受け取り、静的なwebコンテンツだった場合レスポンスをブラウザに返す。しかし、リクエストが動的なwebコンテンツの場合、webサーバでは処理せず、アプリケーションサーバに送る。そして、アプリケーションサーバがミドルウェアを通してアプリに伝える。処理が終わったら、先ほどとは逆の順番で結果をブラウザに返す。\n\n\n参考\n\nwebサーバーとアプリケーションサーバーの違い\nIT用語辞典\nRails開発におけるwebサーバーとアプリケーションサーバーの違い（翻訳）\n","isoDate":"2020-06-20T11:30:34.000Z","dateMiliSeconds":1592652634000}]
